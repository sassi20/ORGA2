EJERCICIO 1

lo que me piden en rangos generales es cuando tarea me pide acceso a memoria me fijo
    - mem no usada por otra, se lo doy y le meto un lock y marco como entregada
    - mem dada a otra entonces lo "rechazo" y desmapeo esta pagina de cualquier otro que no la deberia tener
    porque es como que todos lo que la comparten la tienen pero la idea es "habilitarselas o no 

TASK_LOCKABLE_PAGE_VIRT
TASK_LOCKABLE_PAGE_PHY

-> No voy a modificar el struct de sched_entry_t por ahora pero lo dejo para ver bien como indexar yo 

typedef struct {
  int16_t selector;
  task_state_t state;
} sched_entry_t;

int8_t current_task = 0
int8_t current_lock_owner = -1; // -1 si está libre, si no contiene el id de la tarea que tiene el lock

void get_lock(vaddr_t shared_page){
    //compruebo si la dirección virtual shared_page corresponde a la página compartida, si no es nada
    
    if (shared_page != TASK_LOCKABLE_PAGE_VIRT) {
        return; // dirección no válida, no hago nada
    }

    // combierto a tarea en dueno del lock 
    current_lock_owner = current_task;

    // Desmapeo la página de todas las demás tareas
    for (int i = 0; i < MAX_TASKS; i++) {
        if (i == current_task) continue;

        uint32_t cr3 = obtenercr3(sche_entry_t[current_task].selector);  
        mmu_unmap_page(cr3, TASK_LOCKABLE_PAGE_VIRT);
    }
    
}

-> Para obtener cr3 sigo la idea de como lo hicimos en la clase pre-parcial que era 
    1. Quedarnos con el indice del selector.
    2. Obtener la base de la gdt.
    3. Sumarle el indice multiplicado por el tamaño de la entrada (indexar en el
    índice a un puntero de structs si se hace en C).
    4. Sumarle el offset del cr3 y retornar el valor apuntado. (Obtener el elemento
    cr3 del struct si se hace en C).

uint32_t obtenercr3(int16_t selector) {
    uint16_t gdt_index = selector >> 3;                   // Paso 1: saco el índice en la GDT
    tss_t* tss = (tss_t*) get_gdt_base(gdt[gdt_index]);   // Paso 2: consigo puntero a la TSS
    return tss->cr3;                                      // Paso 3: devuelvo el CR3
}



EJERCICIO 2 

Para hacer mis syscalls voy a registrar mis nuevas syscall en la idt 

IDTENTRY3(99);                              --> lock

#define IDT_ENTRY3(99)
idt[99] = (idt_entry_t) {
.offset_31_16 = HIGH_16_BITS(&_isr 99),
.offset_15_0 = LOW_16_BITS(&_isr 99),
.segsel = GDT_CODE_0_SEL,
.type = INTERRUPT_GATE_TYPE,
.dpl = 3,
.present = 1
}

IDTENTRY3(100);                              --> realese

#define IDT_ENTRY3(99)
idt[100] = (idt_entry_t) {
.offset_31_16 = HIGH_16_BITS(&_isr 100),
.offset_15_0 = LOW_16_BITS(&_isr 100),
.segsel = GDT_CODE_0_SEL,
.type = INTERRUPT_GATE_TYPE,
.dpl = 3,
.present = 1
}

global _isr99

_isr99:
    pushad
    push EDI
    call lock
    popad
    iret

global _isr100

_isr100:
    pushad
    push EDI
    call release
    popad
    iret

--> Ahora si voy a tener que agregar u posible estado de tarea que va a ser TASK_BLOCKED que lo voy a usar para que todas mis tareas me empiecen con la direccion desmapeada y lo voy a mapear en caso de lockearlo


void lock(vaddr_t shared_page) {
        if(shared_page == TASK_LOCKABLE_PAGE_VIRT){

        //caso pedi lock y ya y alguien ya lo tiene 
        if(current_task != -1 && current_task != current_locking_task){
            sched_tasks[current_task].state = TASK_BLOCKED
            siguienteTarea();
        }
        else if (current_locking_task == current_task) {
            //caso que pedi lock y ya lo tengo yo
            return;
        }
        
        //no lo tengo y lo podria tener, hago get_lock
        get_lock(shared_page);
        return;
    }

}

sched_task_offset:     dd 0xFFFFFFFF
sched_task_selector:   dw 0xFFFF

siguienteTarea:
    pushad
    call sched_next_task
    mov word [sched_task_selector], ax
    jmp far [sched_task_offset]
    popad
    iret

void release(vaddr_t shared_page) {
    if(shared_page == TASK_LOCKABLE_PAGE_VIRT){
        //si pido release y efectivamente tengo el lock
        if(current_task != -1 && current_task == current_locking_task){
            current_locking_task = -1;
            for(int i = 0; i < MAX_TASKS; i++) {
                if(sched_tasks[i].state == TASK_BLOCKED) {
                    sched_tasks[i].state = RUNNABLE;

                }

            }
        }
    }


}

b)

Para que funcione esto lo que deberiamos arrancar todo desmapeado, entcones cuando una rutina escriba en la memoria compartida, entonces saltara el page fault.
debemos modificar la rutina de ese page fault para que si fue lectura, simplemente mapee on demand (para saber si fue lectura o escritura miramos el errorcode) y no hace mas nada.
Ahora viene lo distinto:
si fue escritura y habia lock disponible, entonces debemos hacer el mapeo desde la page fault y encima otorgarle el lock a la tarea actual desde la que salto el page fault
usando cr2.
luego se desmpaearan todas las otras excepto esa que tiene el lock.
debemos modificar la rutina de atencion del clock (isr32) para que despues de 5 tiks (usaremos un contador), el lock se libere nuevamente.
Cuando se libere el lock, yo diria que habria que desmapear a todas las tareas del area compartida nuevamente.
y listo
