IDTENTRY3(99);

#define IDT_ENTRY3(99)
idt[99] = (idt_entry_t) {
.offset_31_16 = HIGH_16_BITS(&_isr 99),
.offset_15_0 = LOW_16_BITS(&_isr 99),
.segsel = GDT_CODE_0_SEL,
.type = INTERRUPT_GATE_TYPE,
.dpl = 3,
.present = 1
}

--> Como es una syscall voy a necesitar una entrada de nivel 3

_isr99:
    pushad
    push EDI
    call malloco
    pop EDI
    mov [ESP + offset_EAX], EAX
    popad
    iret

--> Me armo reservas_t que voy a usar como elemento de mi array memoria que lo que va a hacer es almacenarme la informacion relevante 
de cada "pedido" de memoria como el id de la tarea que pidio la memoria, la cantidad que se le dio, la direccion a dicha y el estado de esta (si en uso o por liberar)

typedef struct {
    uint8_t id_tarea;
    size_t resrsva;
    vadder_t memedada;
    bool liberar;       -> iniciada en false
    int32_t cant_pag;   -> iniciada en 0
} reservas_t

--> Modifico el sched_entry_t del tp para agregarle la cantidad de memoria q le estoy dando y chequear no pasarme de los 4 bytes 
y nuevamem va a ser el área de memoria virtual reservable por el proximo llamado malloco

typedef struct {
    int16_t selector;
    task_state_t state;
    size_t reserva;         -> iniciada en 0
    int32_t cant_pag;       -> iniciada en 0
    vadder_t nuevamem;      -> iniciada en 0xA10C0000
} sched_entry_t;

--> En void malloco lo que voy a hacer es fijarme si la catidad de memoria que ya le asigne es >= a 4 y en ese caso no le doy
 y sino le doy, le guardo la direccion y actualizo la proxima a dar, la cantidad dada y el array

PAGE_SIZE = 1 página = 4 KB = 4096 bytes
MAXMEM 4 MB = 4 × 1024 KB = 4096 KB
4096 KB / 4 KB = 1024 páginas


uint8_t current_task = 0
array <reservas_t>  memorias   --> array que va a ser de elementos de tipo reserva_t 
uint8_t pedido = 0          --> va a ser mi indice para mis memorias

void* malloco(size_t size);
    uint32_t pag_act = sched_tasks[current_task].cant_pag; 
    // si la cantidad de paginas que ya tiene y la cantidad que le entrarian en el size que me piden entonces no le doy nada 
    if (pag_act + (size/PAGE_SIZE) > MAXMEM){
        return null
    }
    uint32_t nuevas_paginas = size/PAGE_SIZE;
    reserva[pedido].id_tarea = current_task
    reserva[pedido].reserva = size
    reservada[pedido].paginas += nuevas_paginas;
    reserva[pedido].memdadada = sched_task[current_task].nuevamem;
    sched_task[current_task].paginas += nuevas_paginas;
    uint32_t dir_dada = sched_task[current_task].nuevamem
    sched_task[current_task].nuevamem += nuevas_paginas*PAGE_SIZE; -> asumo quue aca me dan un numero que sea multiplo de el page size y que no me corte a una pagina en la mitad, sino con hacer un +1
    return (void*)(dir_dada);
}

-> En malloco en definitiva esta que el usuario/tarea me va a pedrie espacio en g y yo tengo que traducir eso a paginas porque nose darle  gigas enteras entonces la dificualtad y mi errror estaba por ahi.
--> Lo importante aca era ser muy prolijo con las conversiones de los sizes que me pedian a paginas y viceversa porque en paginas es mas facil operar y en definitiva es el lenguaje que comparto con procesador 

--> En el enunciado me piden que cuando la tarea intente acceder a la memoria que le fue asignada en el pedido tenga allocacion lazy lo que significa que yo no voy a mapear las direcciones virtuales a direcciones fisicas 

bool page_fault_handler(vaddr_t virt) {
    print("Atendiendo page fault...", 0, 0, C_FG_WHITE | C_BG_BLACK);
    pd_entry_t *pd = (pd_entry_t*)(CR3_TO_PAGE_DIR(rcr3()));
    pd_entry_t *pde = &(pd[VIRT_PAGE_DIR(virt)]);
    bool ans = false;
    if (ON_DEMAND_MEM_START_VIRTUAL <= virt && virt <= ON_DEMAND_MEM_END_VIRTUAL && !(pde->attrs & MMU_P)){
      mmu_map_page(rcr3(), virt, ON_DEMAND_MEM_START_PHYSICAL, MMU_U | MMU_W);
      ans = true;
    }
    // lo que miro para ver si esta en rango es chequear si esta entre la direccion que yo doy y la proxima que voy a dar para no mappearle si estoy en una dirrect que se la podria dar pero todavia no la di
    if (virt >= 0xA10C0000 && virt <= sched_task[current_task].nuevamem){
        paddr_t* nueva_pagina = mmu_next_free_user_page(); 
        zero_page(nueva_pagina)
        mmu_map_page(rcr3(), virt, nueva_pagina,MMU_P | MMU_U | MMU_W);
        ans = true;
    }
    // Chequeo si el acceso fue dentro de su memoria registrada
    for(uint16_t i=0; i<1024; i++){
        if(!tiene_reserva_valida(virt)){
            sched_disable_task(current_task);
            liberar_memo_tarea();
            return false;
        }
        paddr_t phy = mmu_next_free_user_page();
        mmu_map_page(cr3, virt, phy, (MMU_P | MMU_U | MMU_W)); // tomo estos atributos porque se aclara que el acceso puede ser por lectura o escritura
        zero_page((virt >> 12) << 12); // se pasa la dirección base de la página virtual a zero_page para inicializarla en cero

    return true;
    }
    return false;
}

global _isr14

_isr14:
	; Estamos en un page fault.
	pushad
    ; Llamar rutina de atención de page fault, pasandole la dirección que se intentó acceder
    mov ecx, cr2
    push ecx
    call page_fault_handler
    pop ecx

    cmp al, 1
    jmp .fin

    .ring0_exception:
	; Si llegamos hasta aca es que cometimos un page fault fuera del area compartida o del área reservada por la tarea

    ; Continuamos con la siguiente tarea
    call sched_next_task

    mov word [sched_task_selector], ax

    jmp far [sched_task_offset]

    .fin:
	popad
	add esp, 4 ; error code
	iret

--> Para chau me voy a tener que definir una nueva idt aunque va a ser igual a a la 99 como no es la misma systcall esto erstaria mal

  IDTENTRY3(100);

  #define IDT_ENTRY3(100)
  idt[100] = (idt_entry_t) {
  .offset_31_16 = HIGH_16_BITS(&_isr 100),
  .offset_15_0 = LOW_16_BITS(&_isr 100),
  .segsel = GDT_CODE_0_SEL,
  .type = INTERRUPT_GATE_TYPE,
  .dpl = 3,
  .present = 1
  }


  _isr100:
    pushad
    push EDI
    call chau
    pop EDI 
    popad
    iret


--> Asumo que los pedidos a memoria fueron definidos por malloco asique se preservarian las estructuras como las habia planteado para este 
Mi idea para este es ir por mi array memoria y voy marcando que las entradas con esa misma direccion las marco como para ser limpiadas. 

void chau(void* ptr):
    vaddr_t virt_a_borrar = (vaddr_t)ptr;
    for (i = 0; i < memoria.size;i ++){
        if (memoria[i].memdada = virt_a_borrar){
            memoria[i].liberar = true;
        }
    }
}


--> Para la tarea especial vamos a tener que agregar una entrada en la gdt para la tss de nuestra nueva tarea. Tambien vamos a tener que agregar una pagina para su directorio,
dos para el stack, una para l page table y en principio dos para el codigo. 
Es necesario que sea de nivel 0 porque sino no podria caeeder al memorias y liberar y desmapear aquellas structs que tengan liberado en true


--> Para garbage collector lo que hago es ir recorriendo mi array y y me voy fijando para cada tarea voy mirando si tiene para liberar memoria 
la desmapeo y limpio los atributos en mi array memorias 

void garbage_collector() {
    while (true) {
        for (int i = 0; i < memoria_size; i++) {  // asumimos que memoria_size es el número de entradas válidas
            if (!memoria[i].liberar)
                continue;

            uint32_t cr3 = conseguir_cr3(memoria[i].id_tarea);
            size_t cantidadPaginas = memoria[i].reserva / PAGE_SIZE;
            if (memoria[i].reserva % PAGE_SIZE) cantidadPaginas++;  // por si no es múltiplo exacto

            for (size_t j = 0; j < cantidadPaginas; j++) {
                vaddr_t virt = memoria[i].memedada + j * PAGE_SIZE;
                mmu_unmap_page(cr3, virt);
            }

            // Limpio la entrada
            memoria[i].memedada = 0;
            memoria[i].reserva = 0;
            memoria[i].id_tarea = 0;
            memoria[i].liberar = false;
        }
    }
}

uint32_t tick_amount(){
    uint32_t res =  (ENVIRONMENT->tick_count)%100;
    return res;
}

conseguir_cr3 lo pienso como lo hicimos en la clase preparcial
1. Quedarnos con el indice del selector.
2. Obtener la base de la gdt.
3. Sumarle el indice multiplicado por el tamaño de la entrada (indexar en el
índice a un puntero de structs si se hace en C).
4. Sumarle el offset del cr3 y retornar el valor apuntado. (Obtener el elemento
cr3 del struct si se hace en C).


--> Para la interrupcion vamos a tener que editar la de 32 ya que es de reloj

_isr32:
    pushad
    ; 1. Le decimos al PIC que vamos a atender la interrupción
    call pic_finish1
    call next_clock

    ; 2. Me fijo cuantos ticks van
    call tick_amount

    cmp eax, 0
    jnz .noCien

    .Cien:
    mov word [sched_task_selector], SELECTOR_TAREA_GC

    jmp far [sched_task_offset]

    .noCien:
    ; 3. Realizamos el cambio de tareas en caso de ser necesario
    call sched_next_task

    cmp ax, 0
    je .fin

    str bx
    cmp ax, bx
    je .fin

    mov word [sched_task_selector], ax

    jmp far [sched_task_offset]


    .fin:
    ; 3. Actualizamos las estructuras compartidas ante el tick del reloj
    call tasks_tick


    ; 4. Actualizamos la "interfaz" del sistema en pantalla
    call tasks_screen_update


    popad

    iret


  https://github.com/ToniusRetonius/Orga-2/tree/main