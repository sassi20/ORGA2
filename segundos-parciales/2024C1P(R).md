RESUELTO EN CLASE PRE-PARCIAL

EJERCICIO 1 

IDTENTRY3(99);

#define IDT_ENTRY3(99)
idt[99] = (idt_entry_t) {
.offset_31_16 = HIGH_16_BITS(&_isr99),
.offset_15_0 = LOW_16_BITS(&_isr99),
.segsel = GDT_CODE_0_SEL,
.type = INTERRUPT_GATE_TYPE,
.dpl = 3,
.present = 1
}

_isr99:
    pushad
    push ESI
    push EDI
    push EAX
    call espiar
    ;acomodo la pila
    add ESP, 12
    ;IMPORTANTE no pisar el resultado con el popad
    mov [ESP+offset_EAX], eax
    popad
    iret


int espiar(uint16_t selector, uint32_t* direccion_a_espiar, uint32_t* direccion_a_escribir){
    
    uint32_t cr3_tarea_a_espiar = obtenerCR3(selector);
    ∕∕ Guardo el cr3 actual
    uint32_t cr3_tarea_espia = rcr3();
    
    paddr_t direccion_fisica_a_espiar = obtenerDireccionFisica(cr3_tarea_a_espiar, direccion_a_espiar);
    if (direccion_fisica_a_espiar == 0) return 1;
    
    ∕∕ Falló si la dirección de memoria no era válida
    mmu_map_page(cr3_tarea_espia, SRC_VIRT_PAGE, direccion_fisica_a_espiar) ∕∕ TO DO
    
    ∕ *Nota: Acá usé SRC_VIRT_PAGE definida en copy_page()
    Podría usar otra dirección virtual pero es importante usar una reservada
    para no pisar un mapeo válido *∕
    ∕∕ Como 4 bytes son 32 bits me alcanza con una variable :D
    uint32_t dato_a_copiar = *((SRC_VIRT_PAGE & 0xFFFFFF000) | VIRT_PAGE_OFFSET(direccion_a_espiar));
    ∕∕ IMPORTANTE no olvidar el offset!
    mmu_unmap_page(cr3_tarea_espia, SRC_VIRT_PAGE, direccion_fisica_a_espiar);
    direccion_a_escribir[0] = dato_a_copiar;
    return 0;
}

Funciones Auxiliares:

uint32_t obtenerCR3(selector){
∕∕ Lo vamos a ver en un rato, en el ejercicio de tareas :)

La idea es
1. Quedarnos con el indice del selector.
2. Obtener la base de la gdt.
3. Sumarle el indice multiplicado por el tamaño de la entrada (indexar en el
índice a un puntero de structs si se hace en C).
4. Sumarle el offset del cr3 y retornar el valor apuntado. (Obtener el elemento
cr3 del struct si se hace en C).

uint32_t obtenerDireccionFisica(uint32_t cr3_tarea_a_espiar,uint32_t* direccion_a_espiar){
    ∕∕ Nos inspiramos en las funciones de map_page y unmap_page
    
    pd_entry_t* pd = (pd_entry_t*)CR3_TO_PAGE_DIR(cr3_tarea_a_espiar);
    int pdi = VIRT_PAGE_DIR(direccion_a_espiar);
    if (!(pd[pdi].attrs & MMU_P)) ∕∕ Si no está mapeada devuelvo 0
    return 0;
    pt_entry_t* pt = (pt_entry_t*)MMU_ENTRY_PADDR(pd[pdi].pt);
    int pti = VIRT_PAGE_TABLE(direccion_a_espiar);
    if (!(pt[pti].attrs & MMU_P)) ∕∕ Idem al anterior
    return 0;
    paddr_t direccion_fisica = MMU_ENTRY_PADDR(pt[pti].page);
    ∕∕ Hasta acá es CASI IGUAL a mmu_unmap_page (solo cambié nombres de variables), ahora en vez de poner el present en 0, solo devuelvo la dirección física
    return direccion_fisica ∕∕ OJO esto devuelve la BASE de la página a la que apuntaba la dirección física (sin el offset
}

EJERCICIO 2 

∕∕ Declaraciones globales relevantes
typedef enum {
    TASK_SLOT_FREE, ∕∕ No existe esa tarea
    TASK_RUNNABLE, ∕∕ La tarea se puede ejecutar
    TASK_PAUSED ∕∕ La tarea se registró
    ∕∕ al scheduler pero está pausada
} task_state_t;

typedef struct {
    int16_t selector;
    task_state_t state;
} sched_entry_t;

static sched_entry_t sched_tasks[MAX_TASKS] = {0};
int8_t current_task = 0;


static sched_entry_t sched_tasks[MAX_TASKS] = {0};
    int8_t current_task = 0
    int8_t last_task_priority = 0;
    int8_t last_task_no_priority = 0;
    uint16_t sched_next_task(void) {
    ∕∕ Buscamos la próxima tarea viva con prioridad
    for ( i = (last_task_priority + 1);
    (i % MAX_TASKS) != last_task_priority;
    i++) {
    if (sched_tasks[i % MAX_TASKS].state == TASK_RUNNABLE
    && es_prioritaria(i)) {
    break;
    }
    }
    ∕∕ A la salida:
    ∕∕ - i != last_task_priority: más de una tarea prioritaria
    ∕∕ - i == last_task_priority == current_task, no quiero repetir
    ∕∕ - i == last_task_priority != current_task,
    ∕∕ última no fue prioritaria
    ∕∕ Ajustamos i para que esté entre 0 y MAX_TASKS-1
    i = i % MAX_TASKS;
    if (i != current_task && es_prioritaria(i)) {
    ∕∕ Hay más de una tarea prioritaria + viva
    ∕∕ o la última tarea ejecutada fue sin prioridad
    last_task_priority = i;
    current_task = i;
    return sched_tasks[i].selector;
    ∕∕ Si llegué acá es porque
    ∕∕ - La última tarea ejecutada fue
    ∕∕ con prioridad (y hay solo una con prioridad)
    ∕∕ - o no hay tareas con prioridad
    ∕∕ - o no hay más tareas vivas
    for ( i = (last_task_no_priority + 1);
    (i % MAX_TASKS) != last_task_no_priority;
    i++) {
    ∕∕ Si esta tarea está disponible la ejecutamos
    if (sched_tasks[i % MAX_TASKS].state == TASK_RUNNABLE) {
    break;
    }
    }
    ∕∕ Si la tarea que encontramos es ejecutable ,
    ∕∕ entonces la corremos.
    if (sched_tasks[i].state == TASK_RUNNABLE) {
    ∕∕ Si llegamos acá, la tarea que encontramos
    ∕∕ no es prioritaria
    last_task_no_priority = i;
    current_task = i;
    return sched_tasks[i].selector;
    }
    ∕∕ En el peor de los casos no hay ninguna tarea viva.
    ∕∕ Usemos la idle como selector.
    return GDT_IDX_TASK_IDLE << 3;
}

_isr32:
    pushad
    call pic_finish1
    call sched_next_task
    ; Si la próxima tarea es 0 o la misma que corre, no saltamos
    cmp ax, 0 ; el scheduler dijo "no cambiamos de tarea"
    je .fin
    str bx ; chequeamos el TR actual
    cmp ax, bx
    je .fin
    mov word [sched_task_selector], ax
    jmp far [sched_task_offset]
    .fin:
    popad
    iret

Funciones auxiliares:
tss_t* obtener_TSS(uint16_t segsel) {
    uint16_t idx = segsel >> 3;
    ∕∕ (esto en realidad se guarda de a partes en la GDT entry)
    return gdt[idx].base;
}

uint8_t es_prioritaria(uint8_t idx) {
    tss_t* tss_task = obtener_TSS(sched_tasks[i].selector);
    uint32_t* pila = tss_task->esp;
}