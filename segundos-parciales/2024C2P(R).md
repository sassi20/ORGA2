Distintas tareas se ocuparán de mostrar los gráficos en pantalla y de realizar otros pre/postprocesamientos de imagen on-the-fly.
Para esto, el sistema debe soportar que las tareas puedan acceder al buffer de video a través de los siguientes mecanismos:
• DMA (Direct Memory Access) - se mappea la dirección virtual 0xBABAB000 del espacio de direcciones de la tarea directamente
al buffer de video.
• Por copia - se realiza una copia del buffer en una pa´gina física específica y se mapea en la dirección virtual 0xBABAB000. Cada tarea debe tener una copia única.

--> La funcion buffer_dma va a recibir al page directory de una tarea y cn ella tiene que hacer la dirrexcion virtual 0xBABAB000 de esa tarea apunten directamente al buffer físico 0xF151C000 y esto va a ser un mapeo directo d memoria compartida sin copiar nada 

EJERCICIO 1 

// Mapeo virtual 0xBABAB000 a físico 0xF151C000 con solo lectura para usuario
void buffer_dma(pd_entry_t* pd) {
    uint32_t cr3 = (uint32_t)pd;
    mmu_map_page(cr3, 0xBABAB000, 0xF151C000, MMU_P | MMU_U);
    return;
}

// Mapeo en espacio de la tarea: lectura/escritura usuario
void buffer_copy(pd_entry_t* pd, paddr_t phys) {
    copy_page(phys, 0xF151C000);                      // copia desde buffer original
    mmu_map_page((uint32_t)pd, 0xBABAB000, phys, MMU_P | MMU_W | MMU_U);  
    return;
}

EJERCICIO 2 

IDEA GENERAL: 
    - Las tareas piden acceso a un dispositivo con opendevice(), y se detienen hasta que el acceso se complete.
    - El dispositivo opera en paralelo (ficticiamente).
    - Cuando el dispositivo termina su operación (por interrupción de hardware: IRQ8 → ISR40), el sistema ejecuta deviceready(), que:
        - mapea o desmapea memoria según el tipo de acceso que se pidió,
        - y reactiva las tareas que estaban esperando.
    - También se puede "cerrar" el dispositivo con closedevice().


Asumo: el scheduler maneja la ejecucion de las tareas en buffer_tasks de la misma manera que las que estan sched_tasks, ya que la estructura que defini tiene todas las mismas caracteristicas que las tareas del scheduler con las que trabajamos (selector y state), ademas de las extras que agregue. El scheduler las puede manejar ya sea con una logica separada especial para estas o tiene mapeos 1 a 1 entre sched_tasks y buffer_tasks.


typedef struct {
  int16_t selector;
  task_state_t state;
  uint8_t access_type = 0;
  vaddr_t virt = 0; //inicializadas en 0
  paddr_t phy = 0;
} sched_buffer_entry_t; //0, 1 o 2 dependiendo del tipo de acceso que requiere

sched_buffer_entry_t buffer_tasks[BUFFER_TASKS]; 
//donde en cada i (numero de tarea que acceden al buffer), esta el tipo de acceso.


-> device ready va a recorrer a la tarea que podria estar usando el buffer y obtiene el cr3 a partir de su selector , en caso de que el acces type sea dos se va a desmapear la pagina que se habia usad0 Se obtiene desde la pila el nuevo buffer (ecx) y se remapea y se guarda ecx para que pueda desmapearse en el futuro. En el caso de ser 1 se llama a la funcion que realiza el acceso directo aa memoria y no hace falta desmapear porque se usa siempre la misma direccion fisica . n el caso del cero se desmapea el buffer de uso general y el que habia sido mapeado en virt, luego se reactiva ;la tarea


global _isr40
_isr40:
    pushad
    call pic_finish1      ;xq es de hardware
    call deviceready
    popad
    iret

void deviceready(){
    for(int i = 0; i < BUFFER_TASKS; i++){
        uint32_t cr3 = get_cr3(buffer_tasks[i].selector) //obtengo el cr3 de las tareas_buf a partir de su sel
        if(buffer_task[i].access_type == 2){ //desmapeo del buffer (no lo va a necesitar mas por ahora)
            uint32_t ecx =  get_ecx(buffer_tasks[i].selector); 
            mmu_unmap_page(CR3_TO_PAGE_DIR(cr3),buffer_tasks[i].phy) //desmapeo el anterior (si el primero es 0 asumo q no hay error)
            buffer_copy(CR3_TO_PAGE_DIR(cr3), ecx); //mapeo el nuevo
            buffer_tasks[i].phy = ecx; //preservo este para desmapearlo luego
        }
        else if(buffer_task[i].access_type == 1){
            buffer_dma(CR3_TO_PAGE_DIR(cr3)); //no hace falta desmapear nada ya que siempre se mapea a la misma direc
        }
        else{ //hay que desmapear los buffer porq no necesita
            mmu_unmap_page(cr3, 0xBABAB000);
            mmu_unmap_page(cr3, buffer_task[i].virt); //PREGUNTAR SI HACE FALTA Y COMO SE HACE
        }
        buffer_tasks[i].state = TASK_RUNNABLE; //reactivo la tarea
    }
}

uint32_t get_cr3(uint16_t selector){
    uint16_t idx = selector >> 3;
    return gdt[idx].base->cr3;
}
uint32_t get_ecx(uint16_t selector){
    uint16_t idx = selector >> 3;
    tss_t* tss = gdt[idx].base;
    uint32_t* pila = tss->esp;
    uint32_t ecx = pila[6];
    return ecx;
}


Vale la aclaracion:
ECX [6]
EDX [5]
EBX [4]
ESP [3]
EBP [2]
ESI [1]
EDI [0]

-> va a pedir acceso al dispositivo, lee el tipo de acceso desde una direc 0xACCE50) y lo pasa como argumento, llama a opendevice_handler que este va a guardar el tipo de acceso y pausa hasta que el despositivo complete su tarea

global _isr90
                                     //opendevice()
_isr90: 
    pushad
    xor eax, eax
    mov al, [0xACCE50] ;paso como param. el acces type
    push eax; lo relevante esta en los 8bits mas bajos
    call opendevice_handler
    pop ecx
    pop al
    popad
    iret


void opendevice_handler(uint8_t access_type){
    buffer_tasks[current_task].access_type = access_type;
    buffer_tasks[i].state = TASK_PAUSED; //pauso la tarea
    return;
}

-> Se va a invocar cuando se quiera sacar el acceso y lo que hace es que limpia el acces type

global _isr91
//closedevice()
_isr91: 
    pushad
    call closedevice_handler
    popad
    iret
void closedevice_handler(){
    buffer_tasks[current_task].access_type = 0;
    return;