EJERCICIO 1

a)
IDT_ENTRY3(99)
    #define IDT_ENTRY3(99)
    idt[99] = (idt_entry_t) {
    .offset_31_16 = HIGH_16_BITS(&_isr99),
    .offset_15_0 = LOW_16_BITS(&_isr99),
    .segsel = GDT_CODE_0_SEL,
    .type = INTERRUPT_GATE_TYPE,
    .dpl = 3,
    .present = 1
}

extern yield_exc_time
extern eax_pending_value

b)
global _isr99
_isr99:
    pushad
    mov [eax_pending_value], eax  ; guardar valor de EAX de la tarea
    call yield_exc_time           ; transferir el control a la tarea 6
    call task_processor
    popad
    iret

-> Voy a modificar  a mi estructura de sched_entry_t

typedef struct {
    int16_t selector;
    task_state_t state;
    bool cedio_cpu;         // indica si esta tarea cedió su CPU
    int8_t destino_id;      // a qué tarea se la cedió (debería ser 5)
    bool esperando_resultado; // la tarea procesadora sabe si hay algo que procesar
    int8_t origen_id;       // desde qué tarea se cedió (lo usa la procesadora para despertarla)
} sched_entry_t;

--> Defino algunas ctes que voy a usar ahora despue

uint8_t proccesor_task = 5;
uint8_t eax_needs_processing = 0;
uint8_t yielding_task = 0xFF;
uint32_t eax_pending_value = 0;

-> yield_exc_time ya a permitir que cuando una tarea "manda" resultado a la tarea procesador (6) tambien le deel tiempo que le reestaba deshabilitandose a ella y habilitando al procesador hasta que este termine 

void yield_exc_time() {
    yielding_task = current_task          -> es el estado que mando la interrupcion
    eax_needs_processing = 1;             -> hay trabajo pendiente para la tarea 6 
    sched_disable_task(current_task);
    sched_enable_task(proccesor_task);    -> activa la tarea 5 
    last_forced_processor = 0xFF; --> preparo la flag para que el scheduler elija a la proccesor_task
    return;
}

c)

void task_processor() {
    while (true) {
        // si salta que hay algo para que mi tarea 6 se procesese
        if (eax_needs_processing) {
            // cargo el valor que me "enviaron" de la otra tarea
            int valor = eax_pending_value;

            // lo porceso en una aux q todavia no paso
            process_value(valor);

            //aviso que ya lo procese 
            eax_needs_processing = 0;
            sched_enable_task(yielding_task);  // reactivar a quien cedió
            sched_disable_task(proccesor_task);  // desactivarse a sí misma
        }
    }
}


-> Para sched next task me traigo el del tpy le hago modificaciones 

uint8_t last_forced_processor = 0xFF; // para evitar repetir


uint16_t sched_next_task(void) {
    // Si hay algo pendiente a procesar y todavía no ejecutamos al procesador
    if (eax_needs_processing && current_task != processor_task && last_forced_processor != processor_task) {
        last_forced_processor = processor_task;  // marcamos que ya lo forzamos una vez (esto va a quedar asi hasta que haya otra syscall asi que solo se fuerza una vez)
        current_task = processor_task;
        return sched_tasks[processor_task].selector;
    }

    // Buscamos la próxima tarea viva (comenzando en la actual)
    int8_t i;
    for (i = (current_task + 1); (i % MAX_TASKS) != current_task; i++) {
        if (sched_tasks[i % MAX_TASKS].state == TASK_RUNNABLE) {
            break;
        }
    }

    // Ajustamos i para que esté entre 0 y MAX_TASKS-1
    i = i % MAX_TASKS;

    if (sched_tasks[i].state == TASK_RUNNABLE) {
        current_task = i;
        return sched_tasks[i].selector;
    }

    // En caso extremo, devolvemos la tarea idle
    return GDT_IDX_TASK_IDLE << 3;
}


d) Dadas las modificaciones al sistema un problema que podria surgir seria que mas de una llamada llame al syscall al mismo tiempo generando asi que nuestras variables globales se pisen entre si y se pierdan valores que se le estan mandando a la tarea 6. Algunas soluciones podibles serian bloquear la syscall cuando ya esta en proceso y volverla a habilitar cuando termino de procesar o generar una lista de pendientes co los diferentes llamados a las syscalls y que el procesador vaya tomandolas en el orden de llegada para asi no editar/cambiar el flujo de los envios de resultados.


EJERCICIO 2 


Cuando una página de memoria modificada (o dirty) es desalojada del sistema (por ejemplo, porque no entra en memoria y hay que hacer lugar), normalmente se guarda en disco para no perder sus cambios.

Pero ahora, quieren hacer una excepción:
➡️ Si la página fue modificada por una cierta tarea (identificada por su CR3), entonces no se debe escribir a disco.

uint8_t Escribir_a_Disco(int32_t cr3, paddr_t phy);
Que debe devolver:

1 → Sí, la página debe escribirse a disco.
0 → No, no se debe escribir.

Entonces tengo que hacer 
    1 obtener el directorio de paginas de la tarea
    2 recorrer todas las entradas del page directory
    3 verificar que la entrada del directorio este presente
    4 recorrer todas las entrdas de esa page tabele
    5 verificar si la entrada mapea:
        si entrada pertenece entonces no se escribe y devuelvo 0 
        sino devuelvo 1


uint8_t Escribir_a_Disco(int32_t cr3, paddr_t phy){
    pd_entry_t* page_dir = (pd_entry_t*)(CR3_TO_PAGE_DIR(cr3)); 
    for (int i = 0; i < 1024; i++){
        if(page_directory[i] & MMU_P){
            pt_entry_t* page_table = (pt_entry_t*) MMU_ENTRY_PADDR(page_directory[i]);
            for(int j = 0; j < 1024; j++){
                if(MMU_ENTRY_PADDR(page_table[j]) == phy){
                    return 0; // la página pertenece a la tarea
                }
            }
        }
    }
    return 1; // la página no pertenece a la tarea 
}

En resumen, La función revisa si la página física phy está mapeada por el directorio de páginas del CR3 dado. Si sí, entonces esa página fue usada por esa tarea, así que no se escribe a disco (return 0).
Si no, entonces sí se debe escribir a disco (return 1).