EJERCICIO 1

Voy a hacer dos syscalls, una va a ser swap_handler la cual va a ser llamada desde una tarea con el id de la que se quiere swapear y esta se va a fijar si hay intencion de cambio desde la otra tarea y en ese cas se realiza el cambio y de no ser asi se guarda la intencion de cambio. Mi segunda syscal va a ser swap_handler_now la cual va a funcionar de manera muyparecida a swap_handler con la diferencia de que en caso de no haber intencion por la segunda tarea no se guarda la intencion de la primera, es decir solo se realiza el cambio si las dos tienen intencion hasta el momento

Primero que nada necesito registrar nuestras syscalls en la idt

IDTENTRY3(99);                                   --> swap
#define IDT_ENTRY3(99)
idt[99] = (idt_entry_t) {
.offset_31_16 = HIGH_16_BITS(&_isr 99 ),
.offset_15_0 = LOW_16_BITS(&_isr 99 ),
.segsel = GDT_CODE_0_SEL,
.type = INTERRUPT_GATE_TYPE,
.dpl = 3,
.present = 1
}

IDTENTRY3(100);                                   --> swap now 
#define IDT_ENTRY3(100)
idt[100] = (idt_entry_t) {
.offset_31_16 = HIGH_16_BITS(&_isr 100 ),
.offset_15_0 = LOW_16_BITS(&_isr 100 ),
.segsel = GDT_CODE_0_SEL,
.type = INTERRUPT_GATE_TYPE,
.dpl = 3,
.present = 1
}

Luego en isr.asm agrego la rutina para ambas interrupciones 

global _isr99
_isr99:
    push edi
    call swap_handler
    pop edi
    iret

global _isr100
_isr100:
    push edi
    call swap_now_handler
    pop edi
    iret

En ambos casos no hago pushad porque justamente el objetivo de la interrupcion es cambiar los registros proposito general y de hacer el pushad y popad lo que hariamos es preservarlos luego cambioarlos pero luego volverian a su estado original que no es lo que queremos. lo unico que vamos  pushear es edi que es la direccion a swaper y c no deberia romper ni el ebp ni esp

Antes de hacer la implementacion en c voy a hacer una modificacion a sched_entry_t para que este tambien almacene que tareas "me pidieron" hacer el swap 

typedef struct {
  int16_t selector;
  uint8_t quieroswap[MAX_TASKS];    --> es un array que va a tener 1 en los id que quieran intercambiar con la tarea 
  task_state_t state;
} sched_entry_t;

quieroswap va a ser esencial debido que lo voy a utilizar para chequear si la tarea que esta pidiendo el swap tambien lo quiere, sino lo voy a "registrar"

int8_t current_task = 0

void swap_handler(int8_t id){ 
    // veo si ambos registros quieren cambio

    if (sched_tasks[id].quieroswap[current_task] == 1){

        // obtengo la direccion -> primero saco el indice en la gdt, luego accedo a la entrada de tss en la gdt y luego calculo la dirección base de ka tss de la tarea para asi quedarme con una dirección apuntero para acceder a los campos de la tarea
        
        uint16_t idx_dst = sched_tasks[id].selector >> 3;
        tss_t* tss_dst = (tss_t*) get_gdt_base(gdt[idx_dst]);

        uint16_t idx_src = sched_tasks[current_task].selector >> 3;
        tss_t* tss_src = (tss_t*) get_gdt_base(gdt[idx_src]);

        // hago el cambio en una auxiliar que dadas dos tss pone los registros de proposito general de una en la otra
        swapTss(tss_dst, tss_src);

        // una vez que hago el cambio saco el "pedido de cambio porque ya fue realizado
        sched_tasks[id].quieroswap[current_task] = 0;
        sched_tasks[current_task].quieroswap[id] = 0;
        sched_enable_task(id);                          // la destino puede despertar xq ocurrio el swap
    }

    // en caso de que ambos registros no quieran el cambio, agrego en el array que la tarea actual lo quiere y mato la tarea para que se siga con otra 

    sched_tasks[current_task].quieroswap[id] = 1; // aviso que quiero swap --> va a ser diferencia con swap now
    sched_disable_task(current_task); // me duermo
}

void swap_now_handler(int8_t id){ 
    if (sched_tasks[id].quieroswap[current_task] == 1){
        
        uint16_t idx_dst = sched_tasks[id].selector >> 3;
        tss_t* tss_dst = (tss_t*) get_gdt_base(gdt[idx_dst]);

        uint16_t idx_src = sched_tasks[current_task].selector >> 3;
        tss_t* tss_src = (tss_t*) get_gdt_base(gdt[idx_src]);
        swapTss(tss_dst, tss_src);

        sched_tasks[id].quieroswap[current_task] = 0;
        sched_tasks[current_task].quieroswap[id] = 0;
        sched_enable_task(id); // la destino puede despertar xq ocurrio el swap
    }
    // aca saco lo que va a ser la diferencia clave con swap_handler porque en este no "guardamos" la 
    sched_disable_task(current_task); // me duermo
}

Funciones auxiliares:

-> swap_u32 lo que hace es tomar dos uint32_t que es el tamano de los registros que vamos a querer almacenar y  con una variable extra pongo a en la variable extra pongo b en a y pongo que b sea la variable extra 

void swap_u32(uint32_t* a, uint32_t* b) {
    uint32_t tmp = *a;
    *a = *b;
    *b = tmp;
}

--> swapTss lo que hace es con las dos tss para cada registro que quiero que sea intercambiado llama a swap dejando ai los registros de de dst en src 

void swapTss(tss_t* dst, tss_t* src) {
    swap_u32(dst->eax, src->eax);
    swap_u32(dst->ebx, src->ebx);
    swap_u32(dst->ecx, src->ecx);
    swap_u32(dst->edx, src->edx);
    swap_u32(dst->esi, src->esi);
    swap_u32(dst->edi, src->edi);
    // EBP, ESP y EIP no se tocan
}

EJERCICIO 2 

Para esta parte del ejercicio y que quede en alojada en la dirección virtual de memoria 0xC001C0DE con el valor
1 si se realizó el intercambio y 0 en caso contrario debo agregar a mi syscalls que en caso de hacer el cambio usando el cr3 de la tarea para mapear y escribir en esa dirección que el cambio fue realizado

void swap_handler2(int8_t id){ 
    // veo si ambos registros quieren cambio

    if (sched_tasks[id].quieroswap[current_task] == 1){
        
        uint16_t idx_dst = sched_tasks[id].selector >> 3;
        tss_t* tss_dst = (tss_t*) get_gdt_base(gdt[idx_dst]);

        uint16_t idx_src = sched_tasks[current_task].selector >> 3;
        tss_t* tss_src = (tss_t*) get_gdt_base(gdt[idx_src]);

        swapTss(tss_dst, tss_src);
        update_swap_state(tss_src->cr3,1);   --> PONGO 1 EN CASO DE CAMBIO REALIZADO

        sched_tasks[id].quieroswap[current_task] = 0;
        sched_tasks[current_task].quieroswap[id] = 0;
        sched_enable_task(id);                          // la destino puede despertar xq ocurrio el swap
    }
    
    uint16_t idx_src = sched_tasks[current_task].selector >> 3;
    tss_t* tss_src = (tss_t*) get_gdt_base(gdt[idx_src]);
    sched_tasks[current_task].quieroswap[id] = 1; // aviso que quiero
    sched_disable_task(current_task); // me duermo
    update_swap_state(tss_src->cr3,0);      --> PONGO 0 EN CASO DE CAMBIO NO REALIZADO
}

void swap_now_handler2(int8_t id){ 
    // veo si ambos registros quieren cambio

    if (sched_tasks[id].quieroswap[current_task] == 1){
        
        uint16_t idx_dst = sched_tasks[id].selector >> 3;
        tss_t* tss_dst = (tss_t*) get_gdt_base(gdt[idx_dst]);

        uint16_t idx_src = sched_tasks[current_task].selector >> 3;
        tss_t* tss_src = (tss_t*) get_gdt_base(gdt[idx_src]);

        swapTss(tss_dst, tss_src);
        update_swap_state(tss_src->cr3,1);   --> PONGO 1 EN CASO DE CAMBIO REALIZADO

        sched_tasks[id].quieroswap[current_task] = 0;
        sched_tasks[current_task].quieroswap[id] = 0;
        sched_enable_task(id);                          // la destino puede despertar xq ocurrio el swap
    }
    
    uint16_t idx_src = sched_tasks[current_task].selector >> 3;
    tss_t* tss_src = (tss_t*) get_gdt_base(gdt[idx_src]);
    sched_disable_task(current_task); // me duermo
    update_swap_state(tss_src->cr3,0);      --> PONGO 0 EN CASO DE CAMBIO NO REALIZADO
}


#define SWAP_STATE_VADDR 0xC001C0DE

--> Lo que va a hacer update_swap_state va a ser meterse en el directorio de paginas (page directory) de la tarea en la que estoy, usando cr3 y en esta busco en su tabla de pagina la direccion fisica que se corresponda a 0xC001C0DE 

void update_swap_state(uint32_t cr3, uint8_t value) {
    pd_entry_t* pd = CR3_TO_PAGE_DIR(cr3);
    uint32_t pd_idx = VIRT_PAGE_DIR(SWAP_STATE_VADDR);
    uint32_t pt_idx = VIRT_PAGE_TABLE(SWAP_STATE_VADDR);
    uint32_t offset = VIRT_PAGE_OFFSET(SWAP_STATE_VADDR);

    // Asumimo que la dirección ya está mapeada en el pd de la tarea
    
    pd_entry_t pd_entry = pd[pd_idx];
    pt_entry_t* pt = (pt_entry_t*) MMU_ENTRY_PADDR(pd_entry);
    pt_entry_t pt_entry = pt[pt_idx];

    paddr_t phys_page = MMU_ENTRY_PADDR(pt_entry);
    uint8_t* swap_ptr = (uint8_t*)(phys_page + offset);

    *swap_ptr = value;
}
