PRIMER EJERCICIO

Lo primero que voy a necesitar para crear mis nuevas syscalls va a ser definirle a cada una su idtentry en idt.c

IDTENTRY3(99);     -> va a ser la correspondiente a crear_pareja

#define IDT_ENTRY3(99)
idt[99] = (idt_entry_t) {
.offset_31_16 = HIGH_16_BITS(&_isr 99),
.offset_15_0 = LOW_16_BITS(&_isr 99),
.segsel = GDT_CODE_0_SEL,
.type = INTERRUPT_GATE_TYPE,
.dpl = 3,
.present = 1
}

IDTENTRY3(100);   -> va a ser la correspondiente a juntarse_con

#define IDT_ENTRY3(100) 
idt[100] = (idt_entry_t) {
.offset_31_16 = HIGH_16_BITS(&_isr 100),
.offset_15_0 = LOW_16_BITS(&_isr 100),
.segsel = GDT_CODE_0_SEL,
.type = INTERRUPT_GATE_TYPE,
.dpl = 3,
.present = 1
}

IDTENTRY3(101);  -> correspondiente a abandonar_pareja

#define IDT_ENTRY3(101)
idt[101] = (idt_entry_t) {
.offset_31_16 = HIGH_16_BITS(&_isr 101),
.offset_15_0 = LOW_16_BITS(&_isr 101),
.segsel = GDT_CODE_0_SEL,
.type = INTERRUPT_GATE_TYPE,
.dpl = 3,
.present = 1
}

Una vez que estas ya estan definidas, en isr.asm agrego la rutina para mis tres interrupciones en isr.asm

global _isr99
_isr99:
    pushad
    call crear_pareja
    popad
    iret

global _isr100
_isr100:
    pushad
    push EDI
    call juntarse_con
    pop EDI
    mov [ESP + offset_EAX], EAX   --> porque sino se me pisa el resultado con el eax viejo y pierdo 
    popad
    iret


global _isr101
_isr101:
    pushad
    call abandonar_pareja
    popad
    iret


Voy a traerme la estructura sched_entry_t del tp pero le voy a hacer unas modificaciones para que se ajuste a mis necesitades para estas syscalls

typedef struct {
    int16_t selector;
    task_state_t state;
    bool en_pareja;          -> 1 si en pareja 0 sino
    bool lider;              -> 1 si lider 0 sino
    bool creo;               -> 1 si llamo a crear pareja y no tiene pareja todavia 
} sched_entry_t;

Asumo que todas las tareas cuando se inician en mis campos nuevos como en_pareja, lider, no_quiere_mas y creo estan en cero,que dirasignada no tiene nada y estado empieza en available.

Tambien a parte de la estructura modificada voy a crearme una nueva estructura que se va llamar pareja va a ser elemento de un array de parejas. 

typedef struct {
    uint8_t id_lider;
    uint8_t pag_lider
    bool liderout = 0;      -> 1 si lider se quiere ir pero tiene que esperar que el otro se vaya primero 
    uint8_t compa;          -> va a tener el id de la tarea compañera y -1 en caso de haber abandonado
    uint8_t pag_compa
    bool habilitada = 1;    -> en principio van a estar habilitada hasta que ambas persdonas de la pareja se hayan ido de esta 
    uint8_t pags_totales
} pareja

Me defino ahora ya con mis estructuras algunas constantes que voy a ir utilizando despues 

uint32_t MAX_MEMORY = 4MB;
MAX_CANT_PAREJAS va a ser el numero maximo de parejas que se pueden generar y va a ser el tamano de mi array pareja
int8_t current_task = 0
array <pareja>  parejas [MAX_CANT_PAREJAS]  --> array que va a ser de elementos de tipo pareja y va a tener tamaño 

uint32_t total_paginas_parejas[MAX_TASKS] = {0}; -> voy a ir guardando cuantas paginas usa cada pareja en un array
int cant_paginas = MAX_MEMORY / PAGE_SIZE;
vaddr_t virt = 0xC0C00000;  -> lo que entrego


void crear_pareja(){
    if (sched_task[current_task].en_pareja == 1){
        return
    }
    sched_task[current_task].creo = 1;
    sched_task[current_task].lider = 1;
    parejas[current_task].lider = current_task;
    total_paginas_parejas[current_task] = 0;       -> reinicio contador porlas dudas  
    sched_disable_task(current_task);
    jump_to_task(sched_next_task());
    return
}

Funcion auxiliar:

La función jump_to_task(selector) le indica manualmente al procesador que cambie de tarea, usando el selector del TSS de la nueva tarea. Reconstruye una dirección segmentada con ese selector y salta a esa tarea con un ljmp, haciendo que el procesador cargue su contexto y comience a ejecutarla.

void jump_to_task(uint16_t selector) {
    asm volatile (
        "ljmp *%0"
        :
        : "m" (*(uint32_t[]){ 0x0 | (selector << 16) })  // offset = 0, selector arriba
    );
}

Sino otra version mas clasica para hacer esto seria hacer que crear_pareja no fuera un void sino que devolviera un 1 0 un cero y entonces en la interrupcion en assemble podriamos hacer que si ese registro esta en 1 hacemos e;l jump far desde la interrupcion 
mov word [sched_task_selector], ax
jmp far [sched_task_offset]



En void crear_pareja lo que se hace es dado un current_task que me esta pidiendo crear una pareja lo que hago es: primero miro que no este en pareja ya si este es el caso no hago nada y returno, luego me fijo que no este buscando paraja, es decir que ya creo_pareja antes pero todavia no tiene compañer@, de ser asi lo marco como bloqueado hasta que consiga companero y por ultimo si no entra en ninguno de los dos casos anteriores indico que creo la pareja, le doy una direccion que va a tener derecho a acceder por ultimo de todo "avanzo entregador_memoria para que no entregue la misma direccion a mas de una pareja.
--> Saco la modificacion al estado porque lo voy a bloquear generando asi que ni siquiera tenga la opcion de volver a llamar a la funcion y efectivamente "bloqueo" la tarea para que no sea ejecutada en el siguiente clock npo como antes que solo le cambiaba un atributo or uno que el kernel no sabia leer y saco lo de la direccion porque estaba mal



int juntarse_con(int id_tarea){
    if (sched_task[current_task].en_pareja == 1){
        return 1;
    }
    if (sched_task[id_tarea].creo == 0){
        return 1;
    }
    parejas[id_tarea].compa = current_task;
    parejas[id_tarea].habilitada = 1;
    sched_task[id_tarea].en_pareja = 1;
    sched_task[id_tarea].creo = 0;
    sched_enable_task(id_tarea)
    sched_task[current_task].en_pareja = 1;
    return 0;
}

En int juntarse_con(int id_tarea) lo que se hace es dado un nuevo id con el que quiere juntarse nuestra tarea llamadora es: primero chequeo que mi tarea llamadora no sea parte de una pareja ya o que la tarea a la cual se quiere unir (id_tarea) no haya creado una pareja, en ambos casos retorno un 1 y no hago mas nada, de no entrar en estos dos casos formo la pareja que consta de agregar una nueva entrada a parejas en donde voy a poner al id_tarea como lider y a current_task como compi, tambien voy a "actualizar" los atributos tanto de id_tarea (haciendolo lider, cambiando el estado de haber estado bloqueado y sacandole que quero pareja ya qie ya la formo y no sigue buscando) como de current_task (que ahora va a estar en pareja y va a tener una direccion asignada de memoria compartida con su pareja). Por ultimo le doy acceso de lectura a current_task sobre la memoria que va a compartir con su pareja mappeando la dirreccion con permiso solamente de lectura.
--> Saco modificacion de estado y lo que hago es updeatear los atributos y volver a habilitar la tarea que creo la pareja en cado de que esta este bloqueada.


void abandonar_pareja(){
    if (sched_task[current_task].en_pareja == 0){
        return
    }
    --> caso en que tarea que pide no es lider 
    if (sched_task[current_task].lider == 0 ){
        sched_task[current_task].en_pareja = 0;
        uint32_t cr3_compi = obtener_cr3(sched_task[current_task].selector);   -> ya lo tengo p/ unmap
        int8_t i_pareja = -1;                                                   -> busco pareja pertenencia
        int8_t id_lider = -1;                                                   -> busco id lider
        for (uint8_t i = 0; i < MAX_PAREJAS; i++) {                             
            if (parejas[i].compa == current_task && parejas[i].habilitada) {   -> guardo intereses
                parejas[i].compa = -1;
                i_pareja = i;
                id_lider = parejas[i].lider;
            }
        }
        // Si el líder ya se quería ir, desmapeamos TODO y limpiamos pareja
        if (parejas[i_pareja].liderout == 1 ) {
            uint32_t cr3_lider = obtener_cr3(sched_task[id_lider].selector);
            for (int j = 0; j < parejas[i_pareja].pag_lider; j++) {        -> desmapeo lo mapeado por lider
                mmu_unmap_page(cr3_lider, virt);
                virt += PAGE_SIZE;
            }
            parejas[i_pareja].pag_lider = 0;
            virt = 0xC0C00000;                         -> como altere el valor me fijo de ponerlo denuevo 
            for (int j = 0; j < parejas[i_pareja].pag_compi; j++) {         -> desmapeo lo mapeado por compi
                mmu_unmap_page(cr3_compi, virt);
                virt += PAGE_SIZE;
            }
            virt = 0xC0C00000;
            parejas[i_pareja].pag_compi = 0
            parejas[i_pareja].pag_totales = 0
            total_paginas_parejas[id_lider] = 0;
            sched_task[id_lider].en_pareja = 0;
            sched_task[id_lider].lider = 0;
            sched_enable_task(parejas[i].lider);
        } else {
            // Si el líder aún no pidió irse, solo desmapeo la mía
            for (int j = 0; j < parejas[i_pareja].pag_compi; j++) {       -> desmapeo lo mapeado por compi
                mmu_unmap_page(cr3_compi, virt);
                virt += PAGE_SIZE;
            }
            virt = 0xC0C00000;
            parejas[i_pareja].pag_compi = 0;
            parejas[i_pareja].pags_totales = parejas[i_pareja].pag_lider;    -> updeteo los totales para ej 2
            total_paginas_parejas[id_lider] = parejas[i_pareja].pags_totales;
        }
        return;
    }
    --> caso en el que se va es lider 
    if (sched_task[current_task].lider == 1 ){
        uint32_t cr3_lider = obtener_cr3(sched_task[current_task].selector);   -> ya lo tengo p/ unmap
        int8_t i_pareja = -1;                                                   -> busco pareja pertenencia
        int8_t id_compi = -1;                                                   -> busco id lider
        for (uint8_t i = 0; i < MAX_PAREJAS; i++) {                             
            if (parejas[i].lider == current_task) { 
                i_pareja = i;
                id_compi = parejas[i].compi;
            }
        }
        //caso en que mi companero ya se fue de la pareja
        if (parejas[i_pareja].compi == -1){
            for (int j = 0; j < parejas[i_pareja].pag_lider; j++) {       -> desmapeo lo mapeado por lider
                mmu_unmap_page(cr3_lider, virt);
                virt += PAGE_SIZE;
            }
            virt = 0xC0C00000;
            parejas[i_pareja].pag_lider = 0;
            parejas[i_pareja].pags_totales = 0;
            total_paginas_parejas[id_lider] = 0
            sched_task[id_tarea].en_pareja = 0;
            sched_task[id_tarea].lider = 0;
        } else {
            parejas[i_pareja].liderout = 1;
            sched_disable_task(current_task);
            jump_to_task(sched_next_task());
        }
    }
}

En void abandonar_pareja() lo que voy a hacer es: si la tarea no pertenece a ninguna pareja no hago nada, si la tarea pertenece a una pareja pero no es el lider, voy a dejar de tener acceso a la direccion de memoria de pareja compartida y me voy a marcar con un -1 como que me fui, si la tarea pertenece a una pareja y es la lider voy a tener dos posibles casos para ambos de estos voy a necesitar saber en que pareja estoy y quien es mi companero asique antes que nads busco eso, una vez que tengo esta info me fijo: si mi companerito ya abandono la tarea yo voy a perder el derecho de acceso a la memoria, voy a salir de la tarea y voy a marcar la pareja en el array de pareja como inhabilitada. Si mi amiguito sigue estando en la pareja solo voy a marcar que me quiero ir de la pareja y me voy a bloquear.
--> Aca basicamente cambie todo. me faltaba el caso donde el compi se iba y el lider se queria ir entonces se iba todo y quedaba runnable la lider, tambien sume que cuando desmapeo saco lo que desmapee del total y hice los desmapeos bien teniendo en cuenta que fue utilizado (en especifico cuantas paginas fueron mapeadas) para no desmapear cosas de mas.

Funcion Auxiliar:
obtener_cr3 lo pienso como lo hicimos en la clase preparcial
en definitiva es como la funcion del tp rcr3 pero en vez de ser para el current task es para cualquier task que yo conosca el selector.
1. Quedarnos con el indice del selector.
2. Obtener la base de la gdt.
3. Sumarle el indice multiplicado por el tamaño de la entrada (indexar en el
índice a un puntero de structs si se hace en C).
4. Sumarle el offset del cr3 y retornar el valor apuntado. (Obtener el elemento
cr3 del struct si se hace en C).

Para que el ejercicio quede completo voy a tener que modificar el page_faul_handler ya que aunque mis interrupciones le dan el derecho de acceso a la direccion entregada para la tarea estas no le dan el acceso real. Es por esto que en el page_fault_handler del tp voy a agregar que se mappen las paginas dadas con sus debidos permisos de ser requerido y contar con los derechos.

bool page_fault_handler(vaddr_t virt) {
    print("Atendiendo page fault...", 0, 0, C_FG_WHITE | C_BG_BLACK);
    pd_entry_t *pd = (pd_entry_t*)(CR3_TO_PAGE_DIR(rcr3()));
    pd_entry_t *pde = &(pd[VIRT_PAGE_DIR(virt)]);
    bool ans = false;
    if (ON_DEMAND_MEM_START_VIRTUAL <= virt && virt <= ON_DEMAND_MEM_END_VIRTUAL && !(pde->attrs & MMU_P)){
        // Mapeamos la página on demand en sí
        mmu_map_page(rcr3(), virt, ON_DEMAND_MEM_START_PHYSICAL, MMU_U | MMU_W);
        ans = true;
    }
    //primero miro que direccion del page fault este en rango perteneciente a mis pags dadas
    // es a partir de mi direc 4 paginas mas porque es 4 gb
    if (virt >= MEMORIA_PAREJAS && virt < MEMORIA_PAREJAS + 0x400000) {
        if (sched_task[current_task].en_pareja == 0 && !(sched_task[current_task].lider == 1 && sched_task[current_task].creo == 1)) {
            return false;
        }
        uint32_t cr3_otro = 0;
        uint32_t attrs = 0;
        for (int i = 0; i < MAX_PAREJAS; i++) {
            if ((parejas[i].id_lider == current_task || parejas[i].compa == current_task) && parejas[i].habilitada == 1) {
            if (sched_task[current_task].lider == 1 && parejas[i].compa != (uint8_t)-1) {
                cr3_otro = obtener_cr3(sched_task[parejas[i].compa].selector);
                attrs = MMU_P | MMU_U | MMU_W;
            } else if (sched_task[current_task].lider == 1 && parejas[i].compa == (uint8_t)-1) {
                attrs = MMU_P | MMU_U | MMU_W;
            } else if (sched_task[current_task].lider == 0) {
                cr3_otro = obtener_cr3(sched_task[parejas[i].id_lider].selector);
                attrs = MMU_P | MMU_U;
            }}
        paddr_t dir_fisica = 0;
        if (cr3_otro != 0) {
            dir_fisica = esta_mapeada(cr3_otro, virt);
        }
        if (dir_fisica == 0) {
            dir_fisica = mmu_next_free_user_page();
            parejas[i].pags_totales++;
        if (sched_task[current_task].lider == 1) {
            parejas[i].pag_lider++;
        } else {
            parejas[i].pag_compa++;
        }
        total_paginas_parejas[current_task]++;
        mmu_map_page(rcr3(), virt, dir_fisica, attrs);
        return true;
    }
  return ans
} 
  
--> en el page_fault_handler lo que hago es:
1 verificar que el page fault se halla generado desde las direcciones posibles que puedo dar las parejas
2 chequeo quien esta accediendo y cual es su situacion con su pareja para determinar que atributos le voy a dar. Si es el lider y creo la pareja, si es el lider y tiene paraja y entonces tiene permiso de lectura y escritura  o si no es lider pero esta en pareja entonces tiene permisos de lectura
3 me fijo si la dirreccion virtual ya posee una direccion fisica asociada para esta tarea, osea en definitiva si esta ya fue mapeada, que si lo fue y tiene una fisica asociada mapeo en esa con los permisos correspondientes 
4 mapeo la direccion virtual a la fisica correspondiente sea la que ya mapeo el companerito o a uhna nueva.


--> esta_mapeada verifica si una dirección virtual virt está mapeada, osea si tiene una página física asignada) en la tabla de páginas asociada al directorio de páginas dado por cr3. si está mapeada, devuelve la dirección física base (página física) correspondiente a esa dirección virtual; si no está mapeada, devuelve 0.En definitiva lo que hace es agarra una dir virtual de una taraa cuyo directorio de páginas base está en cr3, si está mapeada. y si lo esta la devuelve 


uint32_t esta_mapeada(uint32_t cr3, vaddr_t virt) {
    pd_entry_t* directorio = (pd_entry_t*) CR3_TO_PAGE_DIR(cr3);
    uint32_t offset_dir = VIRT_PAGE_DIR(virt);
    if ((directorio[offset_dir].attrs & MMU_P) == 0) {
        return 0;
    }
    pt_entry_t* tabla = (pt_entry_t*) (directorio[offset_dir].pt << 12);
    uint32_t offset_tabla = VIRT_PAGE_TABLE(virt);
    if ((tabla[offset_tabla].attrs & MMU_P) == 0) {
        return 0;
    }
    return tabla[offset_tabla].page << 12;
}


EJERCICIO 2 

Lo que se me ocurre que nose si voy a llegar a implementar bien para uint32_t uso_de_memoria_de_las_parejas(); es agregar a mi struct de parejas dos atributo mas consumo que sea que si pareja accedio a memoria compartida cuanto de esta escribio/leyo, sumando cuando se mapea y restando en caso de que se desmapee esta memoria compartida. Con esto lo que podria hacer para el periodo dado es fijarme que parejas estan habilitadas y de estas ir sumando estos consumos, con este chequeo de que esten habilitadas estoy teniendo en cuenta tanto las parejas que siguen en parejas como las parejas que solo tienen a su lider porque yo habilito a la pareja al momento de crearla y la deshabilito al momento que se van ambos de esta.
Las modificaciones que me quedarian por hacer son:
- sumar atributo a mi struct
- en abandonar pareja restarle a mi atributo consumo todo lo que este liberando 
- en page_fault_habndler deberia sumar a consumo cada vez que mapeo y cuanto
- en juntarse_con cuando creo la pareja voy a tener que habilitarla
- hacer uso_de_memoria_de_las_parejas vaya recorriendo mi array parejas y que si la pareja esta habilitada sume en una variable de tipo uint32_t todos los consumos de las tareas habilitadas y devuelva este resultado 

--> resuelvo en llevar un array que  que lleve la cantidad de paginas usada por la tarea y slo tengo que iterar en ese mas facil, que cuando uno se va  updateo y despues sino cuando deshabilito la pareja lo pongo en cero. Mi idea incial no considero que este mal solo que queda yn poco mas feo porque tendrias que chequear que la pareja este habilitada y agarrar pag_totales, son dos versiones posibles una lleva la info en la struct pareja y otra la va llevando a parte pero same shit :)

uint32_t uso_de_memoria_de_las_parejas(){
    uint32_t paginas = 0;
    for (uint32_t i = 0; i < MAX_TASKS; i++){
        paginas += total_paginas_parejas[i];
    }
    return paginas;
}



CORRECCIONES CORREGIDAS:

crear_pareja
- [x] La tarea debe ser bloqueada en el primer llamado a crear_pareja, no debería ni ser posible que se reciba un segundo llamado de la misma tarea. 
- [x] La implementación asigna direcciones virtuales como si en cada pareja debieran ser distintas, cuando para todas vale el mismo rango de direcciones. Recordá que cada tarea tiene sus direcciones virtuales propias. ❗
- [x] No salta a la siguiente tarea ❗ Esto es sumamente importante. Si tan solo se deshabilita la tarea en el scheduler, la interrupción seguirá ejecutando hasta darle el control nuevamente a la tarea. A partir de ahí la tarea continuará ejecutando bajo la asunción de que creó una pareja cuando esto no es así, dando lugar a todo tipo de errores inesperados.

juntarse_con
- [x]  sched_entry_t[id_tarea].estado = available; Asumiendo que antes el estado era "bloqueado", "available" no es el estado que usa el scheduler para correr la tarea, así que va a seguir sin correr

abandonar_pareja
- [x] mmu_unmap_page(cr3, sched_entry_t[current_task].dir_asignada) Llegado este punto en dir_asignada ya no hay nada.
- [x] La implementación no desmapea las páginas de la tarea lider si esta solicitó abandonar pero la otra tarea aún no se fue. Luego, tampoco las desmapea cuando la otra finalmente se va.
- [x] Sólo se desmapea una página, deberían desmapearse todas las usadas en el rango especificado.

page_fault_handler
- [x] zero_page no trabaja con direcciones físicas, sino virtuales. Recordá que, cuando paginación está activada, toda dirección será interpretada como virtual. Como "nueva_pagina" está en el área de usuario, no es parte del identity mapping y por tanto no va a ser traducida correctamente.
- [x] No se corrobora que "virt" esté en el rango definido por el enunciado, ni que sea la dir_asignada que se almacenó antes ❗
- [x] Siempre se asigna una página nueva, cuando se supone que las parejas compartirían sus páginas en el rango ❗
